###### 块级作用域
+ 块级作用域存在于
   + 函数内部
   + 块中
+ let和const
   + 块级声明用于声明在指定块的作用域之外无法访问的变量
   + let const的特点
      1. 不会被提升
      2. 重复声明报错
      3. 不绑定全局作用域
   + 区别
      + const用于声明变量，其值一旦被设定就不能再被修改，否则会报错
+ 临时死区
   + let和const 再声明之前访问这些变量，会导致报错，只有执行变量声明语句后，变量才会从TDZ中移出
+ 在for循环中的let 相当于在圆括号中建立了一个隐藏的作用域，每次迭代的时候都创建一个新变量，并以之前迭代中同名变量的值将其初始化。
###### 模板字符串
+ 如果你要再字符串中使用反撇号，你可以使用反斜杠转义
+ 在模板字符串中，空格，缩进，换行都会被保留
+ ${} 任意的js表达式都可，大括号中的值不是字符串时，会将其转化为字符串
###### 箭头函数
+ 箭头函数和普通函数
    1. 没有this 需要通过查找作用域链来确定this值，也不能通过call apply bind这些方法改变this指向
    2. 没有arguments 可以通过命名参数或者rest参数的形式访问参数
    3. 不能通过new关键字调用 没有new.target 没有原型 没有super
###### symbol类型
1. symbol值通过symbol函数生成，使用typeof，结果为‘symbol'
2. symbol前面不能加new 否则会报错
3. instanceof的结果会报错
4. symbol可以接受一个字符串作为参数，表示对symbol实例的描述
5. 如果的参数是一个对象，就会调用该对象的toString 方法，将其转化为字符串，然后才生成symbol值
6. symbol函数的参数只是表示当前symbol值的描述，相同参数的symbol函数的返回值是不相等的
7. symbol值不能和其它类型的值进行运算
8. symbol值可以显式得转化为字符串
9. symbol值可以作为标识符，用于对象的属性名，可以保证不会出现相同名的属性
10. symbol值作为属性名，不会穿现在for...in for...of循环中，也不会被Object.keys object.getOwnPropertyNames JSON.stringfy返回。有一个Object.getOwnPropertySymbols方法
11. symbol.for 建立一个全局的symbol
12. symbol.keyfor方法返回一个已登记的symbol类型的key
###### for...of
+ 迭代器
   + 所谓迭代器，就是一个具有next方法的对象，每次调用next都会返回一个结果对象，该结果对象有两个属性，value表示当前值，done表示遍历是否结束
+ es6规定，默认的iterator接口部署在数据结构的symbol.iterator属性，或者说，一个数据结构只要具有symbol.iterator属性，就认为是可遍历的。如果我们使用for...of遍历一个对象，会报错，然而如果我们给该对象添加symbol.iterator属性。
+ 有一些数据结构默认部署了Symbol.iterator属性，所以for...of循环可以使用范围包括
   + 数组  set map  类数组 generator对象 字符串
+ 内建迭代器
   + entries 返回一个遍历器对象
   + keys
   + values
   + 在for...of循环中，如果没有显示指定则使用默认迭代器，数组和set集合的默认迭代器是values map集合的默认迭代器是entries
###### class
+ 类的内部所有的方法，都是不可枚举的
+ 类必须使用new调用，否则会报错。

######
+ 作用域：指的是在程序中定义变量的区域，该位置决定了变量的生命周期，作用域就是变量与函数的可访问范围。
+ 代码块： 如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。
+ ES6是如何解决变量提升代买的缺陷
   1. 函数内部通过var声明的变量，在编译阶段全都被存放到变量环境里面
   2. 通过let申明的变量，在编译阶段会被存放到此法环境
   3. 在函数的作用域内部，let声明的变量并没有存放到此法环境中
   4. 进入作用域块时，作用域块中通过let声明的变量，会被存放在此法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量。
   5. 当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出
###### 作用域链
+ 其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。如果我们在当前作用域中没有找到这个变量，回去上级查找，我们把这个查找的链条叫做作用域链。
###### 闭包
+ 在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。
+ JavaScript 引擎会沿着“当前执行上下文–>foo 函数闭包–> 全局执行上下文”的顺序来查找 myName 变量，
####### this
+ this是和执行上下文绑定的，也就是说每个执行上下文中都有this,
+ 全局上下文中的this
   + 全局执行上下文中的 this 是指向 window 对象的 在严格模式下是undefined
+ 函数执行上下文中的 this
   + 默认情况下this也是指向window
   + call方法设置
   + 对象调用方法设置
   + 构造函数
+ this的缺陷
   1. 嵌套函数中的this不会从外层函数中继承
      + 保存一个self
      + 箭头函数
   2. 普通函数中的this默认指向全局对象window
###### 栈空间和堆空间
+ js是一种弱类型的动态的语言
   1. 所类型 不需要告诉js这个变量是什么类型
   2. 动态： 你可以使用同一个变量保存不同类型的数据
+ 原始类型和引用类型的存储
   1. 对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址
   2. 在 JavaScript 中，赋值操作和其他语言有很大的不同，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址
###### 垃圾回收机制
+ 当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。
+ 代际假说
   1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
   2. 不死的对象，会活得更久。
+ 在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象
+ 新生代
   + 新生代中用Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域
   + 首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，
   + 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。
   + 但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。
   + JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中
+ 老生代
   + 垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。
+ 为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。
###### 编译器和解释器
+ 之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。
+ 生成 AST 需要经过两个阶段。
   1. 第一阶段是分词（tokenize），又称为词法分析
   2. 第二阶段是解析（parse），又称为语法分析
+ 生成字节码
   + 字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。
+ 优化
   1. 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互
   2. 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
   3. 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存