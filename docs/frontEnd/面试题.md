###### rem布局原理深度理解
1. em 作为font-size的单位时，其代表父元素的字体大小，em作为其他属性单位时，代表自身字体大小。
2. rem rem作用于非根元素时，相对于根元素字体大小，作用于根元素时，相当于其初始字体大小。
3. vw 视口宽度的1/100  vh视口高度的1/100
在pc端 视口宽高一般就是浏览器的宽高。在移动端，
4. rem的原理： 我们一般设置rem等于屏幕宽度的1/10
   + 怎么样恒等于屏幕的1/10
   ```
     document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + ‘px‘; 
   ```
5. rem是一种弹性布局，他强调等比缩放，100%还原，他和响应式布局不一样，响应式布局强调不同屏幕需要不同的显示。字体并不适合使用rem，字体大小和字体宽度，并不成线性关系。我们可以在body上做字体修正。
   1. pc端可以通过媒体查询，给body设置不同的而字体大小
   2. 移动端并不适合用在段落上，使用[data-dpr]属性来区分不同dpr下的文本字号大小
###### 前端大文件上传
+ 文件上传的几种方式
   1. 普通表单上传
      + 构建文件上传的表单，并指定表单的提交内容类型为enctype="multipart/form--data";
      + form表单上传大文件时，很容易遇到服务器超时的问题。
   2. 文件编码上传，
      + 主要实现原理式将图片转换成base64进项传递，base64编码的缺点在于其体积比原图更大。
      + 除了进行base64编码，还可以在前端直接读取文件内容以后进行二进制格式上传。
   3. formData异步上传
      + formData对象主要用来组装一组用xmlHttpRequest发送请求的键/值对，可灵活发送ajax请求。
+ 大文件上传
   + 前面讨论的几种上传方式实现大文件上传会遇到超时问题
+ 文件切片
   + 编码方式上传中，在前端我们只要先获取文件的二进制内容，然后对文件内容进行拆分，最后将每个文件的切片上传到服务器即可。
   + 在js中，文件file对象是bolb对象的子类，bolb对象包含一个重要的方法slice,通过这个方法，我们可以对二进制文件进行拆分。
   + 每次请求的时候，上传一部分分块就行。但是这样也是存在问题的。
      1. 无法识别一个切片是属于哪一个切片的，当同时发生多个请求时，追加文件的内容会出错
      2. 切片上传接口时异步的，无法保证服务器接收到切片是按顺序拼接的。
   + 如何将多个切片还原成一个文件呢
      1. 确认所有切片都上传，这个可以通过客户端在切片全部上传后调用mkdir接口来通知服务器进行拼接。
      2. 找到同一个context下的所有切片，确认每个切片的顺序，这个可以在每个切片上标记一个位置索引（可额外拼接用户信息如uid等保证唯一性，也可以根据文件的二进制内容计算文件的hash,这样只要文件内容不一样，则标识也会不一样，缺点就是计算量太大了。）
      3. 按顺序拼接切片，还原成文件。
+ 断点续传：指的是可以从已经上传部分开始继续上传未完成的部分，而没有必要从头开始上传，节省上传时间。
   1. 在切片上传成功后，保存已上传成功的切片信息
   2. 下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传
   3. 所有切片上传完毕后，再调用mkdir接口通知服务器进行文件合并
   + 如何保存已经上传切片的信息：
      1. 通过localStorage等方式保存再前端的浏览器中，这种方式不依赖于服务器，实现起来也比较方便，缺点就是如果客户端清楚了本地文件，会导致上传记录丢失
      2. 服务端本来知道哪些切片已经上传，因此可以由服务器提供一个根据文件context查询已经上传切片的接口，再上传文件前调用该文件的历史上传记录。
      3. 可以通过xhr.upload中的progress方法可以实现监控每一个切片上传进度
###### websocket
+ websocket最大的特点是服务器可以主动向客户端推送小心，客户端也可以主动向服务器发送消息，是真正的双向平等对话。
+ 特点
   1. 建立再tcp协议之上，服务器端的实现比较容易
   2. 与http协议有着良好的兼容性。默认端口也是80和443，，并且握手阶段采用http协议，因此握手时不容易屏蔽，能够通过各种http代理服务器。
   3. 数据格式比较轻量，性能开销小，通信高效。
   4. 可以发送文本，也可以发送二进制数据。
   5. 没有同源策略，客户端可以和任意服务端通信
   6. 协议标识是ws 如果加密，则为wss
+ 
```
  var ws = new WebSocket('ws://xxxx');
```
+ 执行完上面语句之后，客户端就会与服务器进行连接
+ readyState 
   + connectiing 0 正在连接
   + open 1 代表连接成功
   + closing 2 代表连接正在关闭
   + closed 3 代表链接已经关闭，或者打开连接失败
