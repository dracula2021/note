### 浏览器相关的面试题
#### 1. 说一说浏览器缓存
[浏览器资源的加载与解析的影响与原因](https://www.jianshu.com/p/2bc93efe0958)
#### 学习笔记
   1. 浏览器的渲染过程
      + 解析html生成dom树，解析css生成cssOm树
      + dom树和cssom树构建成render树
      + 布局render树
      + 绘制render树
   2. css加载相关
      + csss的解析和加载不会阻塞html的解析。解析dom树的过程和样式表解析成cssDom树的过程是并行的。
      + css解析会阻塞渲染树的生成。
      + 即使link标签的media属性的值不符合当前设备，浏览器仍会加载其对应的css文件。
   3. javascript
      + 所有的js执行都会阻塞html的解析，即使设置了defer或async也是一样的
      + defer和async属性对于inline-script都是无效的。
      + 浏览器不会并行加载多个没有设置defer或async的js资源
      + saync和defer的区别：这两个属性都会使script异步加载，sync会在加载完之后直接执行，而defer会等到html解析完成之后才会执行js代码。
      + js只能获取到存在dom树上的元素，而伪元素并不存在于dom树上，而是存在于渲染树上。
   4. 媒体资源的加载（图片音视频）
      + 图片的加载不会阻塞html的解析，媒体资源的加载是并行加载的。
-------
[浏览器工作原理详解](https://blog.csdn.net/dangnian/article/details/50876241)
#### 学习笔记
   1. 
-------
[浏览器的多进程](https://blog.csdn.net/sh435367384/article/details/79647326)
#### 学习笔记
   0. 了解进程和线程
      + cpu其实在某一特定时刻只能执行一个程序的（先不考虑多核）
      + 进程是操作系统的概念，操作系统在面对同时处理多个程序的时候，将应用程序抽象为进程来运行。这样一来，操作系统就可以根据一定的规则快速的将cpu执行事件这一宝贵的资源分配给不同的进程去处理，因为切换分配的速度很快，所以看起来就像是多个应用程序同时在运行一样。
      + 一个应用程序整体执行的时候会存在多个子任务的情况，因而操作系统又在进行里面划分出线程的概念。有了线程，一个应用程序就可以同时管理自己的多个子任务。cup在某个特定时刻其实只能执行某个线程。
      1. 线程共享进程资源，
      2. 一个线程崩溃，整个进程跟着崩。
      3. 进程之间相互隔离，通过ipc进行通信。
   + 早期的单进程浏览器
      1. 一个进程运行起来包含很多页面甚至很多插件和功能的浏览器，会极其的不稳定（只要一个出错，整个浏览器都挂掉），不流畅和不安全（线程共享进程资源）。
   + 多进程浏览器
      1. 所谓多进程浏览器就是将浏览器的各种不同类别的任务拆分出来，放到多个不同的进程里面去执行，这里会用到一个关键的安全技术sandbox
      2. 沙盒可以看做就是一个被限制了权限的进程，沙箱技术按照安全策略来限制程序对系统资源的使用，进而防止其对系统进行破坏，其有效性依赖于所使用的安全策略的有效性
   1. 浏览器的多进程包括
      + Browser进程：浏览器的主进程，只有一个。作用有：
         1. 负责浏览器界面的显示，与用户交互。
         2. 负责各个页面的管理，创建和销毁其他进程，其他进程是他的子进程。
         3. 将renderer进程得到的内存中的bitmap，绘制到用户界面
         4. 网络资源的管理，下载等。
   2. 第三方插件进程：
   3. GPU进程：最多一个，用于3D绘制等。
   4. 浏览器渲染进程（浏览器内核）：默认每个Tab页面一个进程，互不影响，主要作用为：页面渲染，脚本执行，事件处理等，每个渲染引擎中会运行blink布局引擎，v8 javascripr执行引擎等。
   + 浏览器渲染进程：
      1. GUI渲染进程：
         + 负责渲染浏览器界面，解析HTML,css,构建DOM树和renderObject树，布局和绘制。
         + 当界面需要绘制或者某种操作引发回流时，就会执行。
         + 注意 gui渲染进程和js引擎线程是互斥的，当js引擎执行时GUI线程就会挂起，GUI更新会被保存在一个队列中等待js引擎空闲时立即执行。
      2. js引擎线程：
         + 也成为js内核，负责处理js脚本程序
         + js引擎程序负责解析javascript脚本，运行代码。
         + js引擎一直等着任务队列中任务的到来，然后加以处理
      3. 事件触发线程：
         + 归属于浏览器而不是js引擎，用来控制事件循环（js引擎自己都忙不过来，需要浏览器另开线程协助）
         + js引擎指向代码块如setTimeout(鼠标点击，ajax异步请求等)，会将对应任务添加到事件线程
      4. 定时器线程：
         + 传说中的setInterval和setTimeout线程
         + 浏览器定时计数器并不是js引擎计数的
         +setTimeout中低于4ms的时间间隔算为4ms
      5. 异步http请求线程。
    + 其中我们需要注意到几点
       1. 其他各个进程都是由浏览器主进程启动和管理的，进程间通过IPC进行数据通信。
       2. 渲染进程和插件进程可能不止一个，根据要渲染的页面和插件数而定。
    + 多进程对安全问题的处理主要靠两方面：1.渲染进程和插件进程运行在沙盒环境中；2.相互隔离的进程数据不共享
    + 站点隔离：就是指同一个域下的内容，会放在同一个渲染进程中进行渲染。
       + 适用于页面里面嵌套一个iframe，或者是在一个tab页面打开一个新的tab页面
    + 浏览器进程和浏览器内核的通信进程
       + 浏览器进程受到用户请求，首先要获取到页面内容，随后将任务传递给render进程
       + render进程简单解释后，交给渲染线程，然后开始渲染
       + 渲染线程受到请求，加载页面并渲染页面。
    + javascript的单线程，与它的用途有关，做为浏览器脚本语言，js的主要用途是与用户交互，以及操作dom，这也决定了它只能是单线程，否则会带来很复杂的同步问题。
#### 渲染相关的知识点：
   1. 图层
      + 一般来说，可以把普通文档流看成一个图层，特定的属性可以生成一个新的图层。不同图层的渲染互不影响，所以某些频繁需要渲染的建议单独生成一个新图层，提高性能。
      + 通过以下的几个常见属性可以生成新图层
         1. 3D变换，translate3D,translateZ
         2. will-change
         3. video iframe
         4. position fixed
         5. 通过动画实现的opacity动画转换。
    2. 回流和重绘
       + 重绘是当节点需要更改外观而不会影响布局时，比如改变color
       + 回流时布局或者集合属性需要改变
       + 回流必然导致重绘，重绘不一定会引发回流，回流所需的成本比重绘高得多，
       + 当event loop执行完microtasks后，会判断document是否需要更新，因为浏览器是60Hz刷新频率，每16ms才会更新一次。
       + 然后判断是否有resize或者scroll
       + 常见的引发回流属性和方法
          1. 添加或者删除可见的DOM元素
          2. 元素尺寸改变
          3. 内容变化。浏览器窗口尺寸改变
          4. 计算offsetWidth offsetHeight
          5. 设置style属性的值
       + 减少回流和重绘的方法
          1. 使用translate替代top
          2. 使用visibility替换display:none
          3. 不要使用table布局
          4. css选择符从右向左匹配查找，避免dom深度过深
          5. 将频繁运行的动画变成图层。
* 强缓存
  + 不需要发送http请求，通过相应的字段来检查，http1.0是experies,http1.1是cache-control
  + experies有一个坑就是浏览器时间可能和服务器时间不一致，就会导致判断不准确。
  + cache-control有很多的关键字，
    1. private 只能浏览器缓存，中间的代理服务器不能缓存
    2. public 浏览器和中间的代理服务器都能缓存。
    3
#### localstorage 和 sessionStorage
   + 相同点：
      1. localstorge和sessionStorage一样用来存储客户端的临时信息的对象
      2. 两者都只能存储字符串类型的对象
      3. 存储数据的大小一般为5M
      4. localstorage和sessionStorage不会参与与服务器的通信
   + 不同点
      + localStorage
        1. 生命周期为永久，
        2. 相同浏览器的不同页面间可以共享相同的localStorage，前提是页面属于相同的域名和端口。
      + sessionStorage
         1. 生命周期为当前窗口或者标签页，一单页面关闭，存储的数据就被清空
         2. 不同标签或者页面无法共享sessionStorage的信息
   + 浏览器缓存的图解
   ![缓存](media/cache.png)
      
