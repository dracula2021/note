###### 进程和线程
+ 一个进程就是一个程序的运行实例，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码，运行中的数据和一个执行任务的主线程，我们把这一个运行环境叫进程。
   1. 一个进程里面一个线程出错，都会导致整个进程的崩溃
   2. 线程之间共享进程中的数据
   3. 进程之间的内容相互隔离
+ 多进程浏览器
   1. 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
   2. 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，Chrome会为每个Tab标签创建一个渲染进程
   3. GPU进程。GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，
   4. 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程
   5. 插件进程。
+ 未来面向服务的架构
   + 原来的各种模块会被重构成独立的服务，每个服务都能在独立的进程中运行。
###### 文件传输过程
+ IP: 把数据包送达目的主机
  + 数据包要在互联网上进行传输，就要符合网际协议（Internet protocol 简称IP）标准。计算机的地址就称为ip地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。
+ UDP 把数据包送达应用程序
   + UDP(user datagram protocol) 数据包协议，最重要的信息是端口号。udp头中除了目的端口，还有源端口号等信息。
+ TCP 把数据完整地送达应用程序
   + udp存在的问题
      1. 数据包在传输过程中容易丢失
      2. 大文件会被拆分成很多小的数据包，udp并不知道如何组装这些数据包，把他变成完整的文件
   + TCP(transmission control protocol传输控制协议)是一种面向连接的，可靠的，基于字节流的传输层通信协议
      + 对于数据包丢失的情况，tcp提供重传机制
      + tcp引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。
    + tcp传输的阶段
       1. 连接建立，三次握手
       2. 传输数据阶段，接收端需要对每个数据包进行确认操作
       3. 断开连接 四次挥手来保证双方都能断开连接。
       + tcp牺牲了数据报的传输速度
##### 浏览器端发起http请求流程
1. 构建请求
2. 查找缓存，在真正发起网络请求前，浏览器会先在浏览器缓存中查询是否有要请求的文件。
3. 准备ip地址和端口
   1. 浏览器会请求DNS返回域名对应的ip
   2. 端口如果url中没有指定，默认是80端口
4. 等待tcp队列
   + 同一个域名同时只能建立6个TCP连接，多出的请求会进入排队等待状态
5. 建立TCP连接
6. 发送http请求
   + 发送请求行
   + 发送请求头
+ 服务器断开连接
   + 一般情况夏，一旦服务器向客户端返回了请求数据，他就要关闭TCP连接。keep-alice的话，tcp连接保持打开。
+ 涉及到的缓存
   + dns缓存和页面资源缓存
   + 页面资源缓存涉及到强缓存和协商缓存
![网络图片](../media/http.png)
###### 从输入URL到页面展示
1. 用户输入
   + 地址栏会判读输入的关键字是搜索内容，还是请求的url
2. url请求过程
   + 网络进程会检查本地是否缓存了该资源，如果有缓存资源，那么直接返回资源给浏览器进程，
   + 利用IP地址和服务器建立tcp连接，
      1. 重定向
      2. 响应数据类型处理
3. 准备渲染进程
   + 什么情况运行在同一个渲染进程中
      1. 同一站点 根域名加上协议相同
      2. chrome的策略是，每个标签对应一个渲染进程，但如果从一个页面打开另一个新页面，而新页面属于同意站点的话，那么新页面会复用父页面的渲染进程。
4. 提交文档
   + 提交文档的消息是由浏览器进程发出的，渲染进程收到提交文档的消息后，会和网络进程建立传输管道
   + 等文档传输完成之后，渲染进程会返回‘确认提交’的消息给浏览器进程
   + 浏览器收到确认提交之后，会更新浏览器界面状态
5. 渲染阶段
   1. 构建Dom树：浏览器无法直接理解和使用html，所以需要将html转换为浏览器能够理解的结构-DOM树
      + 通过html解析器解析，最终输出树状结构的Dom
   2. 样式计算 浏览器也无法理解纯文本的css样式，所以当渲染引擎接收到css文本后，会将css文本转换为浏览器可以理解的结构stylesheet
      + 
   3. 布局阶段
      1. 创建布局树
         + 我们要额外构建一棵树只包含可见元素的布局树
      2. 布局计算
         + 
      3. 分层：渲染引擎需要为特定的节点生成专用的图层，生成一颗图层树。
         + 拥有层叠上下文属性的元素会被提升为单独的一层
            + （position z-index filter opcity）
            + 需要裁剪的地方
      4. 图层绘制
         + 将图层树中的每个图层进行绘制，生成绘制列表
      5. 栅格化操作
         + 绘制列表只是用来记录绘制顺序和绘制指令的列表，实际上的绘制操作是由渲染引擎中的合成线程来完成的。
         + 所谓栅格化，就是将图块转换为位图。图块是栅格化的最小单位。
         + 通常栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程佳作快速栅格化。
      6. 合成和显示
         + 我们使用了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，
###### js的执行原理
+ 变量提升
   + 是指在JavaScript代码执行过程中，JavaScript引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的undefined。
   + 一段代码的执行分为编译阶段和执行阶段
      1. 编译阶段
      + 执行上下文
         1. 变量对象，该对象中保存了变量提升的内容
      2. 执行阶段
+ 调用栈：JavaScript引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈
######
+ 作用域：指的是在程序中定义变量的区域，该位置决定了变量的生命周期，作用域就是变量与函数的可访问范围。
+ 代码块： 如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。
+ ES6是如何解决变量提升代买的缺陷
   1. 函数内部通过var声明的变量，在编译阶段全都被存放到变量环境里面
   2. 通过let申明的变量，在编译阶段会被存放到此法环境
   3. 在函数的作用域内部，let声明的变量并没有存放到此法环境中
   4. 进入作用域块时，作用域块中通过let声明的变量，会被存放在此法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量。
   5. 当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出
###### 作用域链
+ 其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。如果我们在当前作用域中没有找到这个变量，回去上级查找，我们把这个查找的链条叫做作用域链。
###### 闭包
+ 在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。
+ JavaScript 引擎会沿着“当前执行上下文–>foo 函数闭包–> 全局执行上下文”的顺序来查找 myName 变量，
####### this
+ this是和执行上下文绑定的，也就是说每个执行上下文中都有this,
+ 全局上下文中的this
   + 全局执行上下文中的 this 是指向 window 对象的 在严格模式下是undefined
+ 函数执行上下文中的 this
   + 默认情况下this也是指向window
   + call方法设置
   + 对象调用方法设置
   + 构造函数
+ this的缺陷
   1. 嵌套函数中的this不会从外层函数中继承
      + 保存一个self
      + 箭头函数
   2. 普通函数中的this默认指向全局对象window
###### 栈空间和堆空间
+ js是一种弱类型的动态的语言
   1. 所类型 不需要告诉js这个变量是什么类型
   2. 动态： 你可以使用同一个变量保存不同类型的数据
+ 原始类型和引用类型的存储
   1. 对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址
   2. 在 JavaScript 中，赋值操作和其他语言有很大的不同，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址
###### 垃圾回收机制
+ 当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。
+ 代际假说
   1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
   2. 不死的对象，会活得更久。
+ 在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象
+ 新生代
   + 新生代中用Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域
   + 首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，
   + 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。
   + 但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。
   + JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中
+ 老生代
   + 垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。
+ 为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。
###### 编译器和解释器
+ 之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。
+ 生成 AST 需要经过两个阶段。
   1. 第一阶段是分词（tokenize），又称为词法分析
   2. 第二阶段是解析（parse），又称为语法分析
+ 生成字节码
   + 字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。
+ 优化
   1. 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互
   2. 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
   3. 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存
###### 消息队列和事件循环
+ 渲染进程专门有一个IO线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给主线程。
+ 消息队列中的任务有哪些？
   + JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等
   + 输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器
+ 消息队列的问题
   1. 第一个问题是如何处理高优先级的任务
      + 针对这种情况，微任务就应用而生了
   2. 第二个是如何解决单个任务执行时长过久的问题。
      + JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行
###### setTimeout是怎么实现的
+ 当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中
+ 这里我们要重点关注它的执行时机，在上段代码中，处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。
+ ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程
+ 定时器的注意事项：
   1. 如果当前任务执行时间过久，会影延迟到期定时器任务的执行
   2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒
   3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒
   5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉
##### xmlhttprequest
   + 回调函数vs系统调用栈
      + 将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数
      + 每个任务在执行过程中都有自己的调用栈，那么同步回调就是在当前主函数的上下文中执行回调函数，这个没有太多可讲的。下面我们主要来看看异步回调过程，异步回调是指回调函数在主函数之外执行，一般有两种方式
         1. 第一种是把异步函数做成一个任务，添加到消息队列尾部
         2. 第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务
+ 宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了
+ 微任务产生的时机和执行为任务的实际
   + 产生微任务的两种方式
      1. MutationObserver dom变化记录的微任务
      2. Promise 
   + 如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束

