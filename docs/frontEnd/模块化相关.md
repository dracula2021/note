###### 模块化详解
+ 什么是模块化
   + 将一个复杂的程序依据一定的规则封装成几个块，并进行组合在一起
   + 块的内部数据与实现是私有的，只向外部暴露一些接口和其他模块通信
+ 模块化的进化过程
   1. 全局function模式 : 将不同的功能封装成不同的全局函数
   2. namespace模式 : 简单对象封装
   3. IIFE模式：匿名函数自调用(闭包)
+ 模块化的好处
   1. 更好的分离, 按需加载
   2. 更高复用性 可维护性
   3. 避免命名冲突
+ 模块化规范
   + commonJs 
      + 特点
          1. 所有的代码运行在模块作用域，不会污染全局作用域
          2. 模块可以多次加载，但是只会第一次加载时运行一次，然后结果缓存了
          3. 模块的加载顺序，按照其出现的顺序
      + 基本语法
         ```
           暴露 module.exports = value 或者 exports.xxx = value
           引入  require()
         ```
    + commonjs模块的加载机制是，输入的是被输出的值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值。
2. AMD 
   + CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。
   + 如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范
   ```
      暴露
      define(function(){});
      引入
      require('',function)
   ```
3. CMD 
   + cmd专用于浏览器端，模块的加载是异步的，cmd是整合了CommonJs和AMD规范的特点，在sea.js中所有的模块都遵循CMD定义规则
4. ES6模块化
   + ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。
   + ES6 模块与 CommonJS 模块的差异
      1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用
      2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口
###### require的原理
+ require的基本使用
   + require的查找
      1. x是内置模块  直接返回该模块
      2. x是文件 先找到x所在的夫模块，quedingx的绝对路径，将x当成文件，依次查找下面文件，只要有一个就返回
         x x.js  x.json x.node
      3. x当成目录
        packagejson中的main字段  x/index.js 
      4. x不带路径 确定x的可能安装目录  依次把x当做文件名或者目录名查找
+ reuire方法是Module原型上的方法，
###### js代码是如何被压缩的
1. 抽象语法树
   + 是源代码的抽象语法结构的树状表达结构，树上的每个节点都表示源代码中的一种结构。
2. 代码压缩原理
   1. 将code转换成AST
   2. 将AST进行优化，生成一个更小的AST
   3. 将新生成的AST再转化为code
3. 压缩规则
   1. 只要表达式语句才能被合并
###### 你不知道的babel
+ javascript是解释型语言，一般会经过词法分析 -> 语法分析 -> 语法树
   1. 词法分析 是将字节流转换为记号流tokens，他会读取我们的代码然后按照一定的规则合成一个个的标识
   2. 语法分析 也成为解析器，将词法分析出来的数组转换成树的形式，同时验证语法，语法有错的话抛出语法错误
+ babel
   + 它主要解决一些浏览器不兼容新特性的问题，把es6代码转化为es5的代码，兼容所有的浏览器
   + 不管是在.babelrc或者babel.config.js文件里面配置都有presets和plugins两个配置项
   + 插件和预设的区别
      presets就是对核心Api预设的代码转换插件包，presets是插件的集合，一个presets内包含了很多的插件
    + webpack的工作流程
       1. shell和config解析
          + webpack.js这个文件中通过optimist将用户配置的webpack.config.js和shell脚本传过来的参数整合成options对象传到下一个流程的控制对象中。
       2. 编译和构建过程
          + webpack的实际入口是compiler中的run方法
          + 构建模块
             1. 调用各loader处理模块之间的依赖，对每一个require用对应的loader进行加工，最后生成一个jsmodule
          + 打包输出
###### webpack相关
+ bundle.js依赖分析
   1. 整个bundle.js其实是一个自执行表达式，传入的参数是一个数组，每个数组的第一项是一个function,function里面是原先js真正的内容
   2. iife 里面有闭包
+ module和chunk的关系
   + 1个chunk可以包含若干个module
###### 前端微服务


