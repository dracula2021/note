###### 进程和线程
+ 一个进程就是一个程序的运行实例，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码，运行中的数据和一个执行任务的主线程，我们把这一个运行环境叫进程。
   1. 一个进程里面一个线程出错，都会导致整个进程的崩溃
   2. 线程之间共享进程中的数据
   3. 进程之间的内容相互隔离
+ 多进程浏览器
   1. 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
   2. 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，Chrome会为每个Tab标签创建一个渲染进程
   3. GPU进程。GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，
   4. 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程
   5. 插件进程。
+ 未来面向服务的架构
   + 原来的各种模块会被重构成独立的服务，每个服务都能在独立的进程中运行。
###### 文件传输过程
+ IP: 把数据包送达目的主机
  + 数据包要在互联网上进行传输，就要符合网际协议（Internet protocol 简称IP）标准。计算机的地址就称为ip地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。
+ UDP 把数据包送达应用程序
   + UDP(user datagram protocol) 数据包协议，最重要的信息是端口号。udp头中除了目的端口，还有源端口号等信息。
+ TCP 把数据完整地送达应用程序
   + udp存在的问题
      1. 数据包在传输过程中容易丢失
      2. 大文件会被拆分成很多小的数据包，udp并不知道如何组装这些数据包，把他变成完整的文件
   + TCP(transmission control protocol传输控制协议)是一种面向连接的，可靠的，基于字节流的传输层通信协议
      + 对于数据包丢失的情况，tcp提供重传机制
      + tcp引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。
    + tcp传输的阶段
       1. 连接建立，三次握手
       2. 传输数据阶段，接收端需要对每个数据包进行确认操作
       3. 断开连接 四次挥手来保证双方都能断开连接。
       + tcp牺牲了数据报的传输速度
##### 浏览器端发起http请求流程
1. 构建请求
2. 查找缓存，在真正发起网络请求前，浏览器会先在浏览器缓存中查询是否有要请求的文件。
3. 准备ip地址和端口
   1. 浏览器会请求DNS返回域名对应的ip
   2. 端口如果url中没有指定，默认是80端口
4. 等待tcp队列
   + 同一个域名同时只能建立6个TCP连接，多出的请求会进入排队等待状态
5. 建立TCP连接
6. 发送http请求
   + 发送请求行
   + 发送请求头
+ 服务器断开连接
   + 一般情况夏，一旦服务器向客户端返回了请求数据，他就要关闭TCP连接。keep-alice的话，tcp连接保持打开。
+ 涉及到的缓存
   + dns缓存和页面资源缓存
   + 页面资源缓存涉及到强缓存和协商缓存
![网络图片](../media/http.png)
###### 从输入URL到页面展示
1. 用户输入
   + 地址栏会判读输入的关键字是搜索内容，还是请求的url
2. url请求过程
   + 网络进程会检查本地是否缓存了该资源，如果有缓存资源，那么直接返回资源给浏览器进程，
   + 利用IP地址和服务器建立tcp连接，
      1. 重定向
      2. 响应数据类型处理
3. 准备渲染进程
   + 什么情况运行在同一个渲染进程中
      1. 同一站点 根域名加上协议相同
      2. chrome的策略是，每个标签对应一个渲染进程，但如果从一个页面打开另一个新页面，而新页面属于同意站点的话，那么新页面会复用父页面的渲染进程。
4. 提交文档
   + 提交文档的消息是由浏览器进程发出的，渲染进程收到提交文档的消息后，会和网络进程建立传输管道
   + 等文档传输完成之后，渲染进程会返回‘确认提交’的消息给浏览器进程
   + 浏览器收到确认提交之后，会更新浏览器界面状态
5. 渲染阶段
   1. 构建Dom树：浏览器无法直接理解和使用html，所以需要将html转换为浏览器能够理解的结构-DOM树
      + 通过html解析器解析，最终输出树状结构的Dom
   2. 样式计算 浏览器也无法理解纯文本的css样式，所以当渲染引擎接收到css文本后，会将css文本转换为浏览器可以理解的结构stylesheet
      + 
   3. 布局阶段
      1. 创建布局树
         + 我们要额外构建一棵树只包含可见元素的布局树
      2. 布局计算
         + 
      3. 分层：渲染引擎需要为特定的节点生成专用的图层，生成一颗图层树。
         + 拥有层叠上下文属性的元素会被提升为单独的一层
            + （position z-index filter opcity）
            + 需要裁剪的地方
      4. 图层绘制
         + 将图层树中的每个图层进行绘制，生成绘制列表
      5. 栅格化操作
         + 绘制列表只是用来记录绘制顺序和绘制指令的列表，实际上的绘制操作是由渲染引擎中的合成线程来完成的。
         + 所谓栅格化，就是将图块转换为位图。图块是栅格化的最小单位。
         + 通常栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程佳作快速栅格化。
      6. 合成和显示
         + 我们使用了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，
###### js的执行原理
+ 变量提升
   + 是指在JavaScript代码执行过程中，JavaScript引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的undefined。
   + 一段代码的执行分为编译阶段和执行阶段
      1. 编译阶段
      + 执行上下文
         1. 变量对象，该对象中保存了变量提升的内容
      2. 执行阶段
+ 调用栈：JavaScript引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈

