###### 执行上下文栈
1. 可执行代码
   + 就三种：全局代码，函数代码。eval代码
2. 执行上下文
   + js引擎创建了执行上下文栈来管理执行上下文。
   + 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。
3. 对于每个执行上下文，都有三个重要属性
   + 变量对象
   + 作用域链
   + this
###### 变量对象
+ 变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。
+ 全局执行上下文
   + 全局对象，全局对象是预定义的对象，作为js的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他预定义的对象函数和属性。
   + 可以用this引用全局对象。
   1. 可以使用this引用
   2. 全局对象是由Object构造函数实例化的一个对象
   3. 预定义了一堆的函数和属性
   4. 作为全局变量的宿主
+ 函数上下文
   + 在函数中，我们用活动对象来表示变量对象
   + 变量对象不可在js环境中访问，只有当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫activation object，只有被激活的对象，上面的属性才能被访问。
+ 执行过程
   1. 进入执行上下文
      + 变量对象包括
         1. 函数的所有形参
            + 由名称和对应值组成的一个变量对象的属性被创建
            + 没有实参时，属性值为undefined
         2. 函数声明
            + 由名称和对应值组成一个变量对象的属性被创建
            + 如果变量对象已经存在相同名称的属性，则完全替换这个属性
         3. 变量声明
            + 由名称和对应值（undefined)组成一个变量对象的属性被创建
            + 如果变量名称跟已经声明的形式参数或者函数相同，则变量声明不会干扰已经存在的这些属性
   2. 代码执行
###### 作用域链
+ 当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一直找到全局下下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。
+ 函数创建
   + 函数的作用域，在函数定义的时候就决定了
      + 函数有一个内部属性[[scope]]，当函数创建的时候，就会保存所有父级变量对象到其中，但是[[scope]]并不代表完整的作用域链
      + 函数激活，当函数激活时，进入函数上下文，就会将活动对象添加到作用域链的前端。
+ 捋一捋
   1. checkscope函数被创建，保存作用域链到内部属性[[scope]]
   2. 执行checkscope函数，创建checkscope函数执行上下文，checkscope函数执行上下文被压入执行上下文栈
   3. checkscope函数不会立即执行，先复制函数[[scope]]属性创建作用域链
   4. 第二步，用arguments创建活动对象，随后初始化活动对象，加入形参，函数声明，变量声明
   5. 第三步，将活动对象压入checkscope作用域链顶端
   6. 准备工作做完了，开始执行函数，随着函数的执行，修改AO的属性值
   