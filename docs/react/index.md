### 正确的学习方式比学习本身更为重要
1. 你真的了解react吗
    + 解释react是什么
        1. 这个题目看似容易，其实很难回答
        2. 我们既要重视知识本身，也要重视表达方法
        + 概念题四字口诀
            1. 讲概念
            2. 说用途
            3. 理思路
            4. 列优缺点 切勿踩一捧一
        + 采用非线性的结构化模式阐述答案
        3. 答案： react是一个网页ui框架，通过组件化的方式解决视图层开发复用的问题，本质是一个组件化的框架。他的核心设计思路有三点：声明式（与JQ相比），组件化，通用性。声明式的优点在于直观与组合，组件化的优势在于视图的拆分和模块复用，可以更容易做到高内聚低耦合。通用性在于一次学习，随处可用。react native等，主要是靠虚拟dom来保证的。缺点是它没有提供完整的一揽子解决方案，在大型开发前端应用中，需要向社区寻找并整合解决方案。为开发者在技术选型和学习适用上造成了一定的成本。
        可以谈谈react优化的看法，对虚拟dom的看法，往自己的项目上引导。
2. 为什么react 要用jsx
    + 通过比较论证证明这个方案更胜一筹
    + 考察：
        1. 技术广度，深挖知识面涉猎广度，对流行框架的模板是否知悉了解
        2. 技术方案调研能力
    + 三步走技巧
        1. 一句话解释jsx
            + js的语法拓展。jsx主要用于声明react元素，react本身并不强制使用jsx，即使使用了，react也会使用babel插件将其转化成react.createElement
        2. 核心概念
            + 所以jsx更像是react.createElement的语法糖，代码编写更为简单，可读性强，react并不希望引入js意外的代码体系，而是想通过关注点分离保持组件开发的纯粹性
        3. 方案对比
            + 关注点分离： 将代码分隔为不同部分的设计原则，是面向对象的设计，关注点分离的价值在于简化程序的开发和维护
            + 模版，引入概念多
            + 模板字符串，描述复杂，预发提示差
3. babel如何实现jsx到js的编译
    + babel读取并解析生成ast,再传入插件进行转换，转换成react.createelment函数
4. 如何避免生命周期中的坑
    + 为什么会有坑，在不恰当的时机调用了不适合的代码，在需要调用时没有调用
    + 通过梳理生命周期，明确生命周期函数职责，确认什么时候该做什么事。
    + 基于周期的梳理，确认生命周期函数的使用方式，
    + 基于职责的梳理，确认生命周期函数的适用范围
    1. constructor是类通用的构造函数，常用于初始化。
    2. getDerivedtateFromProps 本函数的作用是是组件在props变化时更新state
    + 触发时机： props被传入时，state发生变化时，forceupdate被调用时。
    3. unsafe_componentwillmount用于组件将夹在某些操作，但目前被标记为弃用，在react异步渲染机制下，该方法坑会被多次调用。
    4. render函数 返回jsx结构，用于描述具体的渲染内容。并不是渲染操作，渲染是react根据渲染内容来实现的。render函数应该是一个纯函数，不应该产生任何副作用。
    5. componentDidMmount 主要用于组件家在完成时做某些操作。
    + 更新阶段
    1. unsafe_componentwillreceiveProps
    2. getzDerrivedStateFromprops
    3. shouldComponentUpdate 
        + pureComponent是进行浅比较
    4. unsafe_componentwillupdate
    5. render
    6. getSnapshotBeforeupdate返回值会作为componentDidupdate的第三个参数使用
    + 卸载阶段
        1. componentWillUnmount常用来取消定时器
    + 函数组件在任何情况下都会重新渲染，react.memo并不是阻断渲染，而是跳过组件渲染，直接复用最后一次的渲染结果

    + errorBoundary

    

5. 函数组件和类组件的区别
    + 有什么区别这类题应该怎么回答
    1. 求同存异过程中找到它的独特的个性，通过具体的场景逐个阐述它的个性
    + 用途一直，都能作为基础组件的ui
    + 类组件的根基是oop面向对象编程，函数式组件的根基是FP 也就是函数式编程
    + 函数式组件更简单 纯粹
6. 如何设计react组件
    +  把只作展示，独立运行，不额外增加功能的组件，称为哑组件，或者无状态组件，展示组件。
    + 把处理业务逻辑与数据状态的组件称为有状态组件，灵巧组件，灵巧组件一定包含至少一个灵巧组件或展示组件
    + 展示组件复用性高
        + 代理组件 
        + 样式组件
        
    + 灵巧组件专注于业务逻辑
        + 容器组件： 拉取数据，组合组件
        + 高阶组件 逻辑复用，链式调用 渲染劫持
7. setState是同步更新还是一部更新
    + 用于变更状态，触发组件重新渲染，修改试图
    + 合成事件： react给document挂上事件监听，dom事件触发后冒泡到document react找到对应的组件，造成一个合成事件出来，并按组件树模拟一遍事件冒泡
    + 通常我们认为setSate是异步的，批量合并操作
        + 保持内部的一致性
        + 后续架构升级启用并发更新
    + 在原生事件中 addEventListener setTimeout setInterval中会同步更新
    + isBatchingUpdate来控制是否异步更新，在生命周期，和合成事件中，可以异步更新

8. 组件跨层级通信
    + 是否有大型前端项目的经验
    + 一个基本，多个场景，结合实际场景
        1. 父与子：
            + props传递
        2. 子与父
            + 主要依赖回调函数 
        3. 兄弟组件
            + 父组件进行中转 
        4. 无直接关系
            + context
            + 全局变量和事件（不推荐） 暂存临时变量，跳出了设计模式，在后续的维护中会有麻烦

9. 状态管理框架
    + 横跨多层级的组件
    + flux
        + 单向数据流，使用很少
    + redux
        + 单一数据源
        + 纯函数reducer
            + 副作用： 在任何具备业务价值的web应用必要执行复杂逻辑，如ajax请求等异步作业，这类逻辑使函数在每次执行过程中，产生不同变化，这样与外界的交互叫做副作用
            + redux如何解决副作用
                1. dispatch时有middlware中间层拦截分发action添加额外行为
                    + redux-thunk
                2. 允许reducer层直接处理副作用

        + state是只读的，唯一可以改变state的是action
    + mobx
        + mobx通过监听的方式
        + mobx5之前是通过object.defineproperty,5之后是通过proxy
        
    + 个人观点

10. virtual Dom的原理
    + 讲概念： facebook创建xhp的目的
        1. 简化前端开发
        2. 避免跨站点脚本攻击
        + 虚拟dom内部确保字符转义，确实可以规避xss，但是他保留了dangerouslysetinnerhtml
        + 不要直接操作dom，通过虚拟dom避免风险
        + react.createElement生成一个plainobject，转化之后变成虚拟dom
        + diff函数，
        3. 大量的直接操作dom容易引起页面性能下降，这时react基于虚拟dom的diff处理与批量操作可降低dom的操作范围与频次，提升页面性能
        4. 首次渲染和微量修改的时候
        5. 虚拟dom的跨平台成本更低
    + 缺点 
        1. 内存占用较高
        2. 无法进行极致优化
11. react的diff算法
    + 对比其他框架进行阐述
    + 先分类，后讲述
    + react和vue是国内主要的前端框架
    1. react的diff算法
        1. 核心概念
            + diff算法探讨的就是虚拟dom树发生变化后生成dom树更新补丁的方式
            + 对比差异，更新真实dom以达到更新视图的效果
        2. 具体流程
            1. 真实的dom首先会映射为虚拟dom
            2. 当虚拟dom发生变化后，会更具差距计算生成patch,patch是结构化的数据，包含增加，更新，移除等
            3. 根据patch去更新真实的dom,反馈到用户界面上
            4. react采用的深度优先遍历，保证了组件生命周期的时序不错乱，但传统的diff算法带来一个严重的性能瓶颈，复杂度O(n^3),
            5. react采用一个经典的手法将复杂度降低为O(n)就是分治，树，组件，元素三个层级进行处理优化
                1. 忽略节点跨层级操作场景，提升比较效率
                    + 需进行树比较，即对树进行分层比较，两颗树只对同一层节点进行比较，发现节点不存在则该节点及子节点完全删除，不会进一步比较
                2. 如果组件的class一致，则默认为相似的树结构，否则默认为不同的树结构，不进行树比较，react.memo
                3. 统一层级的子节点，可通过标记key的方式进行列表对比，元素比对主要发生在同层级中，通过标记节点操作生成补丁

    2. 横向对比
        + preact 没有patch操作
        + vue patch算法 首位四个节点比较，其他基本跟react一样，但是缺乏时间切片
    3. 性能优化
        1. 根据diff算法的设计原则，应尽量避免跨层级的家电操作，
        2. 通过设置唯一key进行优化，尽量减少组件层级的深度，因为过深的层级会加深遍历深度，带来性能问题
11. 解释react的渲染流程
    1. 如只是简单复述流程，缺乏重点侧写，那只是知道的程度
    2. 如解释清楚设计理念并将核心流程穿插在具体化抽象概念中进行描述，才是吃透原理。
    3. 在上点基础上，加自己理论心得，工程实践，辅以具体落地成果

    + 破题 讲话有重点，层次要分明
    1. 通过主线串联整个分散论点
    2. 渲染过程很繁杂
    + 按阶段进行划分

    + react的渲染
        1. 核心
            1. 协调 reconciler 
                + react15及以前版本的渲染方案，其核心是以递归的方式逐级调度栈中子节点到父节点的渲染
                + fiber reconciler 核心设计是增量渲染，将渲染工作分割为多区块，将其分散到多个帧中进行
                + react 中babel转移发生在本地的node进程中，而不是浏览器
                + react事务都是基于。。。
            2. fiber 在开发中是指一种最轻量化的线程，对于系统内核是不可见的，也不能由内核进行调度，运行模式被称为协作式多任务，线程采用的模式是抢占式多任务
                + 协作式多任务模式下，线程会定时放弃自己的运行权利告知内核让下一个线程运行

        2. 阶段
        3. 调度
        4. 事物
12. 解决问题，预防问题，工程化的角度去思考方案应该怎么做
    + 通过标准化的方案解决同类型的问题
    + 是否具有团队视野
    + 量化成功 工程是一门重视过程和结果的
    1. 渲染异常
        1. 现象
            + 组件内的js错误，会导致react内部状态被破坏并在下一次渲染时产生可能无法追踪的错误，这些错误基本上是由较早的其他错误音wide，react没有提供一种在组件中优雅处理这些错误的方式，也无法从错误中恢复
            + 简而言之，页面崩溃，白屏
        2. 避免
            + getDerivv
            + 预防
                + render中return 后的jsx都是进行数据的拼装和转换
                + 如果拼装过程中出错，会导致编译失败
                + 但如果在转换过程中出现错误，就很不容易被发现 后端数据是否可靠 null-safety 
                    1. idx
                    2. 可选链操作符 
                
            + 兜底
                + 给关键的组件展示兜底
                + 兜底页面上报
            + 兜底页面的统计，线上报警

13. 分析和调优
    + 一个完整的解决方案应该说清楚标准，讲清楚缘由，理清楚过程算清楚结果，最后用数据和收益来说明你的工作结果
    1. 建立衡量标准
        1. 知道问题出在哪里，页面慢，
        2. rail模型，response animation idel load
        3. lighthouse的测量工具，点击genereate report
        4. 不同的网络环境，不同的浏览器
        5. new relic
    2. 确认优化原因
    3. 实施方案过程
    4. 计算收益结果

