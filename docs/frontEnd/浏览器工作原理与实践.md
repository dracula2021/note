###### 进程和线程
+ 一个进程就是一个程序的运行实例，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码，运行中的数据和一个执行任务的主线程，我们把这一个运行环境叫进程。
   1. 一个进程里面一个线程出错，都会导致整个进程的崩溃
   2. 线程之间共享进程中的数据
   3. 进程之间的内容相互隔离
+ 多进程浏览器
   1. 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
   2. 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，Chrome会为每个Tab标签创建一个渲染进程
   3. GPU进程。GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，
   4. 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程
   5. 插件进程。
+ 未来面向服务的架构
   + 原来的各种模块会被重构成独立的服务，每个服务都能在独立的进程中运行。
###### 文件传输过程
+ IP: 把数据包送达目的主机
  + 数据包要在互联网上进行传输，就要符合网际协议（Internet protocol 简称IP）标准。计算机的地址就称为ip地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。
+ UDP 把数据包送达应用程序
   + UDP(user datagram protocol) 数据包协议，最重要的信息是端口号。udp头中除了目的端口，还有源端口号等信息。
+ TCP 把数据完整地送达应用程序
   + udp存在的问题
      1. 数据包在传输过程中容易丢失
      2. 大文件会被拆分成很多小的数据包，udp并不知道如何组装这些数据包，把他变成完整的文件
   + TCP(transmission control protocol传输控制协议)是一种面向连接的，可靠的，基于字节流的传输层通信协议
      + 对于数据包丢失的情况，tcp提供重传机制
      + tcp引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。
    + tcp传输的阶段
       1. 连接建立，三次握手
       2. 传输数据阶段，接收端需要对每个数据包进行确认操作
       3. 断开连接 四次挥手来保证双方都能断开连接。
       + tcp牺牲了数据报的传输速度
##### 浏览器端发起http请求流程
1. 构建请求
2. 查找缓存，在真正发起网络请求前，浏览器会先在浏览器缓存中查询是否有要请求的文件。
3. 准备ip地址和端口
   1. 浏览器会请求DNS返回域名对应的ip
   2. 端口如果url中没有指定，默认是80端口
4. 等待tcp队列
   + 同一个域名同时只能建立6个TCP连接，多出的请求会进入排队等待状态
5. 建立TCP连接
6. 发送http请求
   + 发送请求行
   + 发送请求头
+ 服务器断开连接
   + 一般情况夏，一旦服务器向客户端返回了请求数据，他就要关闭TCP连接。keep-alice的话，tcp连接保持打开。
+ 涉及到的缓存
   + dns缓存和页面资源缓存
   + 页面资源缓存涉及到强缓存和协商缓存
![网络图片](../media/http.png)
###### 从输入URL到页面展示
1. 用户输入
   + 地址栏会判读输入的关键字是搜索内容，还是请求的url
2. url的地址如果不是一个Ip地址而是域名则通过DNS将该地址解析成IP地址，IP地址对应着网络上的一台计算机，DNS在解析域名的时候有两种方法：递归查询和迭代查询
   + 递归查询的流程
      1. 首先会查询浏览器缓存 
      2. 没找到，就回去检查系统缓存，检查本地的硬盘host文件。如果找到就可以直接使用
      3. 没找到就查找路由器缓存
      4. 查询ISP DNS缓存（本地名称服务器缓存）
      5. 本地服务器再以客户端的角色发送与前面一样的NDS域名查询到上层，一次或多次转发，从本地服务器到权威名称服务器再到顶级名称服务器，最后到跟名称服务器。
   + 迭代查询
      1. 前面的一样，但是发送到本地服务器，如果本地没有，就返回他的根服务器给DNS客户端，
      根服务器会把顶级服务器地址返回，顶级如果有缓存记录，则直接把对应的记录项返回给DNS客户端，否则查询对应的二级域名的服务器地址返回给客户端
2. url请求过程
   + 网络进程会检查本地是否缓存了该资源，如果有缓存资源，那么直接返回资源给浏览器进程，
   + 利用IP地址和服务器建立tcp连接，
      1. 重定向
      2. 响应数据类型处理
3. 准备渲染进程
   + 什么情况运行在同一个渲染进程中
      1. 同一站点 根域名加上协议相同
      2. chrome的策略是，每个标签对应一个渲染进程，但如果从一个页面打开另一个新页面，而新页面属于同意站点的话，那么新页面会复用父页面的渲染进程。
4. 提交文档
   + 提交文档的消息是由浏览器进程发出的，渲染进程收到提交文档的消息后，会和网络进程建立传输管道
   + 等文档传输完成之后，渲染进程会返回‘确认提交’的消息给浏览器进程
   + 浏览器收到确认提交之后，会更新浏览器界面状态
5. 渲染阶段
   1. 构建Dom树：浏览器无法直接理解和使用html，所以需要将html转换为浏览器能够理解的结构-DOM树
      + 通过html解析器解析，最终输出树状结构的Dom
   2. 样式计算 浏览器也无法理解纯文本的css样式，所以当渲染引擎接收到css文本后，会将css文本转换为浏览器可以理解的结构stylesheet
      + 
   3. 布局阶段
      1. 创建布局树
         + 我们要额外构建一棵树只包含可见元素的布局树
      2. 布局计算
         + 
      3. 分层：渲染引擎需要为特定的节点生成专用的图层，生成一颗图层树。
         + 拥有层叠上下文属性的元素会被提升为单独的一层
            + （position z-index filter opcity）
            + 需要裁剪的地方
      4. 图层绘制
         + 将图层树中的每个图层进行绘制，生成绘制列表
      5. 栅格化操作
         + 绘制列表只是用来记录绘制顺序和绘制指令的列表，实际上的绘制操作是由渲染引擎中的合成线程来完成的。
         + 所谓栅格化，就是将图块转换为位图。图块是栅格化的最小单位。
         + 通常栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程佳作快速栅格化。
      6. 合成和显示
         + 我们使用了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，
###### js的执行原理
+ 变量提升
   + 是指在JavaScript代码执行过程中，JavaScript引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的undefined。
   + 一段代码的执行分为编译阶段和执行阶段
      1. 编译阶段
      + 执行上下文
         1. 变量对象，该对象中保存了变量提升的内容
      2. 执行阶段
+ 调用栈：JavaScript引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈
######
+ 作用域：指的是在程序中定义变量的区域，该位置决定了变量的生命周期，作用域就是变量与函数的可访问范围。
+ 代码块： 如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。
+ ES6是如何解决变量提升代买的缺陷
   1. 函数内部通过var声明的变量，在编译阶段全都被存放到变量环境里面
   2. 通过let申明的变量，在编译阶段会被存放到此法环境
   3. 在函数的作用域内部，let声明的变量并没有存放到此法环境中
   4. 进入作用域块时，作用域块中通过let声明的变量，会被存放在此法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量。
   5. 当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出
###### 作用域链
+ 其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。如果我们在当前作用域中没有找到这个变量，回去上级查找，我们把这个查找的链条叫做作用域链。
###### 闭包
+ 在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。
+ JavaScript 引擎会沿着“当前执行上下文–>foo 函数闭包–> 全局执行上下文”的顺序来查找 myName 变量，
####### this
+ this是和执行上下文绑定的，也就是说每个执行上下文中都有this,
+ 全局上下文中的this
   + 全局执行上下文中的 this 是指向 window 对象的 在严格模式下是undefined
+ 函数执行上下文中的 this
   + 默认情况下this也是指向window
   + call方法设置
   + 对象调用方法设置
   + 构造函数
+ this的缺陷
   1. 嵌套函数中的this不会从外层函数中继承
      + 保存一个self
      + 箭头函数
   2. 普通函数中的this默认指向全局对象window
###### 栈空间和堆空间
+ js是一种弱类型的动态的语言
   1. 所类型 不需要告诉js这个变量是什么类型
   2. 动态： 你可以使用同一个变量保存不同类型的数据
+ 原始类型和引用类型的存储
   1. 对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址
   2. 在 JavaScript 中，赋值操作和其他语言有很大的不同，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址
###### 垃圾回收机制
+ 当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。
+ 代际假说
   1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
   2. 不死的对象，会活得更久。
+ 在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象
+ 新生代
   + 新生代中用Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域
   + 首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，
   + 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。
   + 但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。
   + JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中
+ 老生代
   + 垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。
+ 为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。
###### 编译器和解释器
+ 之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。
+ 生成 AST 需要经过两个阶段。
   1. 第一阶段是分词（tokenize），又称为词法分析
   2. 第二阶段是解析（parse），又称为语法分析
+ 生成字节码
   + 字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。
+ 优化
   1. 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互
   2. 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
   3. 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存

###### 页面性能分析
+ 什么是Dom html文件的字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是Dom 
+ Dom有三个层面的作用
   1. 视觉来看，dom是生成页面的基础数据结构
   2. js脚本来看，js可以对dom结构进行访问，从而改变文档的结构 样式和内容
   3. 安全视角来看，dom是一道安全防护线，一些不安全的内容在dom解析阶段被拒
+ dom的生成
   + 在渲染引擎内部，有一个叫HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构
   + HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。
   + 字节流转换为dom需要三个阶段
      1. 通过分词器将字节流转换为Token
      2. 将token解析为Dom节点
      3. 将dom节点添加到Dom树中
   + html解析器开始工作时，会默认创建一个根为document的空Dom结构
   + js时如何影响dom生成的呢
      + 渲染引擎判断这是一段脚本，此时html解析器会暂停dom的解析,js引擎接入，并执行这段脚本。
      + 如果引入的js  暂停渲染，先下载脚本，然后执行
         + 因为下载js css时耗时的，浏览器会有预解析。
         + 如果js文件中没有操作dom相关的代码，可以将js脚本设置为异步加载。
            + async一旦脚本加载完成就会立即执行
            + defer 需要载domcontentloaded事件之前执行
         + 样式文件会阻塞js的执行
+ 从css的加载角度来缩短白屏时间
   1. 内联js css来移除这两个文件的下载，这样可直接渲染html
   2. 压缩js
   3. 不需要再解析html阶段使用的js标记上sync defer
   4. 对于大的css文件，通过媒体查询属性，将其拆分成多个css文件
###### 渲染引擎的分层和合成机制
+ 显示器是怎么显示图像的
   + 每个显示器都有固定的刷新频率，通常60hz，每秒60此固定读取前缓冲区的图像，并将其读取的图像显示在显示器上。
   + 显卡的职责就是合成新的图像，并将图像保存在后缓存区
+ 帧和帧频
   + 我们爸爸渲染流水线生成的每一幅图成为一帧，如果某一帧生成时间过久，就会感到卡顿。为了解决卡顿，我们引入了分层和合成机制。
   + 可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换
###### 如何系统优化页面
+ 加载阶段
   + 如图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件
   1. 减少关键资源的个数
      + css js改成内联
      + sync defer
   2. 减少关键资源大小
      + 压缩css js 移除注释
   3. 减少关键资源的RTT次数
+ 交互阶段
   1. 减少js脚本执行时间
   2. 避免强制同步布局
      + 强制布局：强制将计算样式和布局操作提前到当前的任务中
   3. 避免布局抖动
   4. 合理利用css合成动画
   5. 避免频繁垃圾回收 尽可能避免小颗粒对象的产生
###### 虚拟Dom
+ Dom的缺陷
   + DOM 结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作都是非常耗时的，这就给我们带来了真正的性能问题
   + 什么是虚拟Dom
###### 组件化
+ 什么是组件化： 对内高内聚，对外低耦合。对内各个元素彼此紧密联系，相互依赖，对外和其他组件的联系很少且接口简单。
+ WebComponent 给出了解决思路，它提供了对局部视图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局
###### 白屏相关的知识点
+ 白屏是一个怎样的过程
   1. 浏览器安全策略对解析html造成的影响
      + 当CSS样式文件没有下载完成时，浏览器解析HTML遇到了内联JS代码。此时，浏览器暂停js脚本执行，暂停html解析，直到css文件下载完成，
   2. 白屏性能优化
      1. DNS 
         + dns缓存优化
         + dns预加载优化
         + 稳定可靠的dns服务器
      2. TCP网络链路优化
      3. 服务器端处理优化 
      4. 浏览器下载 解析渲染页面的优化
         + 尽可能精简html的代码和结构
         + 简化css文件和结构
         + 合理放置js代码。
###### 前端性能优化
   + response 事件处理最好在50ms内完成
      1. 复杂的js计算放在后台
      2. 超过50ms的响应，一定要提供反馈，倒计时或者百分比
   + animation  在10ms内产生一帧
   + load： 传输内容到页面可交互的时间不要超过5s
      + 使用lazy-load code-splitting等手段，让第一次加载的资源更少

###### 重绘和重排
+ 当dom的变化影响了元素的几何信息，浏览器需要重新计算元素的集合属性，将其安放在界面中的正确的位置。重拍也叫回流
   + 增加 删除 改变元素位置，尺寸 内容 字体大小 设置style属性的值，查询属性或者调用某些方法都会触发reflow
+ 重绘 ：当一个元素的外观发生改变，但是没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。
+ 重拍的代价是高昂的，会破坏用户体验，让ui展示非常迟缓。
+ 减少重拍
   1. 尽可能在低级别的dom节点上修改样式
   2. 不要使用table布局
   3. 减少重排次数  样式集中修改 分离读写操作 使其脱离文档流 优化动画
####### 网络图片加载的优化方案
   + 图片加载存在的问题和原因
      1. 启动页面时加载过多图片
         + 在chrome浏览器中，同一个域名下，最多支持6个请求的并发，其他的请求将会推入队列中等待或者停滞不前。
         + 解决方案
            + 大部分图片不是首屏所需的，可以延迟首屏不需要的图片的加载，v-img指令去设置图片的加载，bind和inserted钩子函数中加载速度相差200ms，如果我们在inserted中去判断时序需要加载，延迟时间有点长
            + 我们其实本身就知道哪些图片是在首屏的

              
      2. 部分图片的体积过大
      

